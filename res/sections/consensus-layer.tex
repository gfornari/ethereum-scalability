\subsection{Consensus layer}
\label{sec:consensus}

The ultimate aim of the blockchain technology is to provide a \textbf{total
order to transactions} in a distributed ledger~\cite{bib:the-quest} without
relying on a trusted third party. This permits to solve the double spending
problem~\cite{bib:bitcoin}. Moreover, in Ethereum the order of transactions can
also affect the execution of smart contracts by altering the content of its
storage.

Finding an agreement on the order of transaction (i.e. the actual blockchain)
and the world status is crucial, thus multiple consensus algorithms were
proposed~\cite{}. Ethereum follows an idea very close to the consensus algorithm
of Bitcoin, which is also known in the literature as \textbf{Nakamoto
consensus}~\cite{}.

The basic idea of this algorithm consists in:
% enumerate* means in-line enumeration
\begin{enumerate*}[label=(\arabic*)]
	\item accepting only valid blocks with regards to some validation criterion,
	and
	\item relying on a \textbf{selection rule} to choose between two different
	valid forks, depending on the amount of work performed in each fork.
\end{enumerate*}

The \emph{validation criterion} used to determine whether a block is valid or
not consists in
\begin{enumerate}
	\item checking that the blocks and transactions are well-formed
	\item re-performing all the transactions
	\item re-executing \emph{all}	the EVM computations to verify whether the
	transaction receipts and the state root contained in the propagated block
	(\autoref{fig:world-state}) are valid.
\end{enumerate}

The \emph{selection rule} is required to avoid the infamous double spending
problem. Indeed, in Bitcoin (and as well in Ethereum) the assumption is that the
majority of computing power belongs to good players who will follow the
rules\todo{add the exact proportion}. Therefore, in order to prevent bad agents
to rewrite the transactions history with a high probability~\cite{bib:bitcoin}
the issuer of new blocks should prove that she invested resources in its
creation
by solving a computational heavy task. This mechanism is known as
\textbf{Proof-of-Work} (PoW). In Bitcoin the selection rule consists in
accepting the longest chain that corresponds roughly to the one with more work
invested on it.
Although the Ethereum community claims to implement a simplified version of
the Greedy Heaviest-Observed Sub-Tree (GHOST) selection
rule~\cite{wood2018ethereum}, actually it is not the
case~\cite{bib:securityAndScalabilityPoW}.
Indeed, currently the selection rule consists in choosing the fork with the
highest accumulated difficulty~\cite{wood2018ethereum}. Each block in the
chain has an associated difficulty that determines how much effort is needed to
mine a new block. This parameter depends \emph{solely} on the difficulty of
the previous block and the time that elapsed between the previous block's 
timestamp and the new block's timestamp, corrected with some bounds to avoid 
sudden decreases or increases in this value. The claim to use the GHOST rule
are motivated by the fact that the headers of stale blocks up to six blocks
before 
(\emph{ommers}) can be included in the blockchain and rewarded, 
but they do neither contribute
to the difficulty of the blocks nor are verified to be 
valid~\cite{bib:securityAndScalabilityPoW}.
Thus, this rule do not permit to keep the same
level of security while augmenting the transaction throughput by diminishing
the block interval, that was the primary aim of GHOST selection
rule~\cite{bib:ghost}.


Since the nodes need to agree on the validity of the state, they need also to
agree on how to move to a new valid state, that is, how to execute a
transaction, as well as how to create a new contract and to execute a message
call. We briefly describe them below.

%In the case of bitcoin this task consists in finding a number (\emph{nonce})
%such that the hash of the block along with the nonce itself begins with a
%number of leading zeros. The difficulty of the task increase exponentially with
%the number of leading zeros. Since the output of the hash function is not
%predictable, the creator of a new block should try each possible nonce in a
%brute-force manner. Once a valid nonce is found the block is spread and the
%receiver should only perform a single hash to check that the result is valid.

