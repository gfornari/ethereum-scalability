\subsection{Propagation Layer}

\subsubsection{RLPx}

The RLPx protocol suite's objectives are manifold.
On the one hand it allows the maintenance of the peer to peer network
and a routing table for each peer through an UDP\footnote{All communications
except those for the node discovery use TCP messages.} node discovery
protocol.
On the other hand it provides a transport layer for the devp2p wire protocols
(Section \ref{sec:devp2p-wire-protocol}) to send their messages.
For security reasons these messages between the peers should be
authenticated and encrypted. Therefore RLPx provides a first handshake,
in which the peers exchange a cryptographic
secret, i.e. a set of tokens used to encrypt the messages
between them\footnote{It is beyond the scope of this report to
	describe the exact procedure. For further details we refer to the official
	documentation~\cite{} and to the go ethereum implementation~\path{}.}.
This secret is valid until no subsequent connection between them fails.
The RLPx protocol suite takes its name by the union of \textbf{RLP} and
\textbf{extended}. The Recursive Length
Protocol~\cite{wood2018ethereum,bib:ethereumrlpspec} is
the serialization algorithm used in Ethereum to both marshal the content of
the RLPx messages to send over the wire and to store information locally.
Details about how does it work are reported in appendix~\ref{sec:appendix:RLP}.





\subsubsection{Devp2p-Wire Protocol}
\label{sec:devp2p-wire-protocol}
This protocol exploits RLPx and have the four message types
\textbf{Hello}, \textbf{Disconnect}, \textbf{Ping} and \textbf{Pong}.
The Hello (Handshake) message is used upon connection and upon receiving a
message of this kind.
This message specifies the protocol version, the client's id,
a string that uniquely identifies a client program, the capabilities and their
version, the port on which the client listen and finally the ID of the node.
The capabilities are the application level protocols supported by the sender
of the Hello Message. At the moment of writing this essay only the protocols
eth (Ethereum), les (light Ethereum Subprotocol), bzz (Swarm) and
shh (whisper) are used. In the following
Section we will describe the Ethereum Wire Protocol, i.e. the application
level protocol of Ethereum.
The disconnect message notifies the receiver that the sender is going to
disconnect itself. The disconnect message can specify optionally an
integer that encodes a reason.
For the complete reason codes we refer to the devp2p specification~\cite{}.
The Ping and Pong message are used to check whether the counterpart is still
on-line or not.

\paragraph{Ethereum Wire Protocol}
The Ethereum wire protocol
(\textit{eth})~\cite{bib:ethereumwireprotocol} is used to spread the information
about the blockchain and for the synchronization. There are several versions
of this protocol. Throughout this section we will consider only the versions
$62$ and $63$ (which are compatible) that are currently supported by the go
Ethereum client (v. 1.8.3).

The first message that must be exchanged between two peers
is the \textbf{Status} message. This kind of message is used to exchange
the: protocol version, the network IDs, the total difficulty of the
heaviest chain known, the best hash, the hash of the best known block and
finally the genesis block's hash. This message should be sent only during
the handshake phase.
If the network id, the genesis id are different or the supported
\textit{eth} protocol version are not compatible the peers should
drop the connection, since they are either on different chain or cannot
communicate with each other.

\subparagraph{Protocol Version 62 - Model Syncing}
To spread the presence of one or more blocks to peers that are not aware
of them the \textbf{NewBlockHashes} message type is used.
Moreover the \textbf{Transactions} message type spreads transactions to
peers who are not aware of them. It is specified that
in the same session a peer should not send twice the same
transaction to a
recipient\footnote{To this extent the
geth implementation (in the file \path{eth/peer.go}) keeps track for each
peer of the set of transactions hash (\texttt{knowTxs}) and the set of
block hash (\texttt{knownBlocks}) known to be known by it.}.
The \textbf{GetBlockHeaders} message type requests to the recipient at most
\texttt{maxHeaders} block headers descendant from the block with a given
number or a given hash.
The recipient of the message should respond with a \textbf{BlockHeaders}
message, in which it has the faculty to send a reply with less than
\texttt{maxHeaders} headers. Clearly, if the recipient of a message
is not aware of any descendant of the given block, it sends a valid empty
reply. Furthermore to request and to receive the real content of the blocks the
peers have the \textbf{GetBlockBodies} and \textbf{Blockbodies} messages.
The requester specifies the hashes of the blocks it wants and the recipient
replies with the bodies (i.e. the transactions and the uncles) of
the required block(s).
Finally, the \textbf{NewBlock} message spreads a single new block.

\subparagraph{Version 63 - Fast synchronization}
From version v. x of geth it is possible to perform a fast synchronization.
This synchronization type does not require that a node performs \emph{all} the
computations happened during the history (i.e. the whole EVM instructions).
Indeed the synchronizer downloads along the blockchain the transaction receipts,
i.e. useful information about the execution of the transaction.
This allows the synchronizer to deal only with the verification of the
proof-of-work. At least in geth this synchronization is possible only by the
first synchronization for security
reasons~\footnote{\url{https://github.com/ethereum/go-ethereum/pull/1889}}.
After the synchronizer reaches a \textit{pivot point} ($head - 1024$) it
retrieves the whole current state and afterwards processes the blockchain
normally.
To perform this synchronization the clients dispose have available
the \textbf{GetReceipts} and \textbf{Receipts} messages, which are the
request for the receipts given the hash and the replies, respectively.
Besides these there are also the \textbf{GetNodeData} and
\textbf{NodeData} message types which provides the mean to exchange
\todo{Add what is a node data. It is not clear in the specification}.




