\subsubsection{RLPx Transport Protocol}
\label{sec:rlpx-transport-protocol}

The aim of this protocol is to provide a generalized mean to build arbitrary
authenticated and encrypted protocols. The protocols built on top of this 
framework are known as subprotocols. Everyone can create a new subprotocol by 
simply selecting $3$ ASCII characters to uniquely identify the protocol and by
defining a list of packet types and the expected structure of their content, 
that would be encoded with the RLP algorithm.

\begin{figure}
    \begin{center}
        \includegraphics[width=\textwidth]{./res/img/rlpx-transport}
        \caption{Relationship between TCP, RLPx and the subprotocols}
        \label{fig:rlpx-transport}
    \end{center}
\end{figure}

The relationship between TCP, RLPx and the subprotocol packets is depicted 
in~\autoref{fig:rlpx-transport}\footnote{For the sake of simplicity here we 
report only single-framed RLPx packets, but we redirect the interested readers 
to the official documentation~\cite{rlpx} to get details about multi-framed 
packets.}. The RLPx transport protocol packets are sent as payload in a TCP 
packet. If we do not consider the MAC codes used to encrypt the information, 
these packets consist of two fields:
\begin{itemize}
    \item a header, which specifies information such as the size of the frame 
    and the subprotocol that will be used
    \item the frame, which is the packet of the subprotocol
\end{itemize}

In turn the subprotocol packet contain a code that uniquely identify the message
type (packet-type) and its content, that is specific to the subprotocol. The 
content of this packet is serialized using the RLP marshaling algorithm.

When two peers establish a connection with RLPx transport protocol they perform
a two-way handshake:
\begin{enumerate}
    \item Encoding Handshake, it is used to exchange a cryptographic 
    secret\footnote{It is beyond the scope of this report to describe the exact 
    procedure. For further details we refer to the official documentation 
    \cite{rlpx} and to the go Ethereum implementation 
    \url{https://github.com/ethereum/go-ethereum/blob/master/p2p/rlpx.go}.}
    that is used to encrypt and authenticate the subsequent RLPx messages 
    between them.
    \item Protocol Handshake, in which the peers exchanges and agree on the 
    subprotocols and versions, that both support (from now these pairs will be 
    referred as \emph{capabilities}).
%    send to the other one a \texttt{Hello} 
%    message, that contain the list of supported capabilities. Each one
%    independently compute the list of common capabilities and sort it according 
%    to the lexicographic order. Since each protocol have a predefined amount
%    of reserved message types, it is possible to build a data-structure to get 
%    from the packet-type the protocol-type. We show how it works with the mean
%    of an easy example. Let's suppose that the peers have only the three protocols
\end{enumerate}

To perform the protocol Handshake, and in general to establish and keep the
connection at this layer, a special subprotocol is involved. In the official
documentation this protocol is known as \devpp{} Wire 
Protocol~\cite{devp2pwire}. This subprotocol reserves sixteen message-types 
although it currently implements only four. The \verb+Hello+ (Handshake) 
message is used for the protocol handshake. This message specifies, among
others, the protocol version, the \textbf{capabilities} and their version, the 
port on which the client listens and the node ID. The \verb+Disconnect+ message 
notifies the receiver that the sender is going to disconnect itself. The 
disconnect message can specify optionally an integer that encodes a reason. For 
the complete reason codes, we refer to the \devpp{} 
specification~\cite{devp2pwire}. The \verb+Ping+ and \verb+Pong+ messages are 
used to check whether the counterpart is still on-line or not.

After the protocol handshake both peers know the shared capabilities.
So, they can compute independently the list of shared capabilities and sort
it lexicographically. Since each protocol have a predefined 
amount of reserved message types, it is possible to build a data-structure to 
get from the packet-type the protocol-type. We show how it works with the mean
of an easy example shown in~\autoref{table:capabilities}. Let's suppose that 
the peers share the capabilities (expressed as tuples $\langle$subprotocol, 
version$\rangle$) $\langle$abc, 4$\rangle$, $\langle$abc, 5$\rangle$ and 
$\langle$zzz, 2$\rangle$. Furthermore, suppose that the subprotocols, 
reserve $9$, $10$ and $5$ message types, respectively. The first row of the 
Table represent the fact that the rlpx transport protocol reserves the first 
$16$ message ids. So, if one of the peer receive the message of type 
\texttt{0x1B} it can determine that the message should be interpreted as the
message of type \texttt{0x01} of capability $\langle$abc, 5$\rangle$.

We notice that although the RLPx Header (\autoref{fig:rlpx-transport}) contain
a field to specify the protocol type, it is not used by the implementation
of Ethereum (at least geth and ethereumj\footnote{Since all the implementations 
should be interoperable, it means that all implementations do not use this
field.}). If it would be the case it would be sufficient to use the 
protocol-type in the RLPx header to identify uniquely a protocol.





\begin{table}
    \begin{center}
        \begin{tabular}{c | c | c }
            Capability & Reserved-IDs & Effective ID\\
            \hline
            - & \texttt{[0x0, 0x10]} & \texttt{[0x0, 0x10]} \\
            $\langle$abc, 4$\rangle$ & \texttt{[0x0, 0x8]} & \texttt{[0x11, 0x19]}  \\
            $\langle$abc, 5$\rangle$ & \texttt{[0x0, 0xA]} & \texttt{[0x1A, 0x24]}  \\
            $\langle$zzz, 2$\rangle$ & \texttt{[0x0, 0x4]}  & \texttt{[0x25, 
                0x3A]}
        \end{tabular}
        \caption{Example of data-structure build after the Protocol Handshake}
        \label{table:capabilities}
    \end{center}
\end{table}





