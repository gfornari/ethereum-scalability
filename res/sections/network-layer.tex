\subsection{Network layer}
\label{sec:network-layer}

The aim of this layer is to build the peer-to-peer network, a decentralized
architecture in which the nodes are logically equivalent and function as a
\emph{servent} (i.e. a node that acts as a client and a server at the same
time). In this type of architecture, the nodes are formed by processes and the
links represent the possible communication channels, that is, a
\textbf{structured overlay network} \cite{van2017distributed} in which the nodes
of the network can propagate the information efficiently. Essentially, this
layer is constituted by a slight modification of the Kademlia protocol
\cite{bib:kademlia}. In the Ethereum jargon, this protocol is known as
\textbf{RLPx Node Discovery Protocol}.


\paragraph{Kademlia protocol}
The Kademlia protocol is a distributed hash table (DHT) system based on the
XOR-metric for distance \cite{bib:kademlia}, that is the distance between two
keys $x$ and $y$ is given by $x \otimes y$. 
The nodes have a unique $m$-bit (e.g., $160$) identifier (ID) and are 
\emph{logically} the leaves of a binary tree of size $2^m$. 
The identifier of a node corresponds
to the path from the root of this tree to the position of the node.

Each node in the network maintains a series of $m$
lists, which contain the contact information of some nodes at a given
XOR-distance from them.
In particular, the $i$-th list of a given node contains
information regarding nodes at distance between $2^i$ and $2^{i+1}$ from 
it's ID.
The maximal capacity of these lists, $k$, is chosen to minimize the
probability that all the nodes in the lists fail at the same 
time and memory requirements.
This parameter is  known as \emph{system-wide replication parameter}.
Because of their maximal capacity the lists are denoted by the term
\emph{k-bucket}.
Each bucket is kept sorted: at the head we find the least-recently seen node
and at the tail the most recently ones.
When a node $R$ receives a message from a sender $S$, $R$
checks if the $k$-bucket corresponding to the sender's ID (SID) already contains
it. If it is the case, SID is moved at the end of the list. Otherwise we should
distinguish two cases:
\begin{enumerate*}[label=(\arabic*)]
  \item if the $k$-bucket is full, then $R$ pings the head ($H$) of the
  $k$-bucket and, if this responds, $S$ is discarded and $H$ is put at the end
  of the list, otherwise $H$ is evicted and SID is inserted at the end of the
  list,
  \item otherwise (i.e. the is still space in the $k$-bucket), the SID is simply
  inserted at the end of the list
\end{enumerate*}.
The rationale to prefer already known contacts to the new ones discovered is due
to the observation that the more a node has been on-line, the more likely it is
to remain up another hour \cite{bib:kademlia}.

% Description of the PROTOCOL's functions
The original Kademlia protocol is based on four RPC functions: \verb|PING|,
\verb|FIND_NODE|, \verb|STORE| and \verb|FIND_VALUE|, and their replies. In
Kademlia, \verb|STORE| and \verb|FIND_VALUE| are used, respectively, to save a
$\langle key, value\rangle$ pair in the DHT and later retrieve it. Since these
features are not needed for a pure node discovery, they are not implemented in
the Ethereum variant. Indeed, there are only the \verb|PING| function, which is
used to check whether a node is still on-line or not, and the
\verb|FIND_NODE(ID)| call used to retrieve the $k$ neighbors closest to the
target \verb|ID|, known by the recipient of the message. In the RLPx
specification we can find also the \verb|PONG| and \verb|NEIGHBORS| instructions
that are the reply messages for \verb|PING| and \verb|FIND_NODE|, respectively.
Apart from the missing functions, RLPx has other important differences from
Kademlia: the IDs are 512 bit long, the XOR distance metric is done on the
sha3 (Keccak-256) of the IDs (a 256 bit long hash) and not directly on the
IDs, and finally the packets are signed with the public key corresponding to the
ID.

In order to join the network for the first time, a new node should generate a
new public-private key pair \footnote{The public key is the ID and the private
key is used to sign the packets.}, and know the address of at least one
participant. In Ethereum this task is accomplished by hard-coding the contact
information of some \textit{bootstrap nodes} in the client's code. The aim of
these nodes is to provide new nodes with contact information to other regular
nodes that are already participating in the network.

RLPx uses its own URL scheme, the \emph{enode}. In this scheme are specified the ID
of the node encoded in hexadecimal format, the IP-Address and the TCP-Port of
the node:
\begin{verbatim}
enode://<hexadecimal-node-id>@<IP>:<TCP-Port>[?discport:<UDP-PORT>]
\end{verbatim}
The \verb|discport| part is optional and is required only if the UDP port
(discovery port) does not correspond to the TCP one. The default discovery UDP
port is 30303.

