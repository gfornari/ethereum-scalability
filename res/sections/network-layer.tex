\subsection{Network layer}
\label{sec:network-layer}

The aim of this layer is to build the peer-to-peer network, a decentralized
architecture in which the nodes are logically equivalent and function as a
\emph{servent} (i.e. a node that acts as a client and a server at the same
time). In this type of architecture, the nodes are formed by processes and the
links represent the possible communication channels, that is, a
\textbf{structured overlay network} \cite{van2017distributed} in which the nodes
of the network can propagate the information efficiently. Essentially, this
layer is constituted by a slight modification of the Kademlia protocol
\cite{bib:kademlia}. In the Ethereum jargon, this protocol is known as
\textbf{RLPx Node Discovery Protocol}.

\begin{algorithm}
\begin{algorithmic}

	\State distance $\gets$ SID $\otimes$ RID
	\State bucket $\gets$ bucket containing nodes at the given distance
	\If {SID $\in$ bucket}
	\State move SID to the end of bucket
	\Else
	\If {bucket not full}
	\State insert SID at the end of the list
	\Else
	\State $H \gets head(bucket)$
	\State ping $H$
	\If {$H$ replies}
	\State Move $H$ to the end of the list and discard S
	\Else 
	\State Evict H and put SID at the end of the list
	\EndIf
	\EndIf
	\EndIf
\end{algorithmic}
\caption{Pseudo-code algorithm to update a bucket upon receiving a message from
a node. The sender and the receiver are denoted by the letters $S$ and $R$,
respectively.}
\label{alg:kademlia:update}
\end{algorithm}


\paragraph{Kademlia protocol}
The Kademlia protocol is a distributed hash table (DHT) system based on the
XOR-metric for distance \cite{bib:kademlia}, that is the distance between two
keys $x$ and $y$ is given by $x \otimes y$. 
The nodes have a unique $m$-bit (e.g., $160$) identifier (ID) and are 
\emph{logically} the leaves of a binary tree of size $2^m$. 
The identifier of a node corresponds
to the path from the root of this tree to the position of the node.

Each node in the network maintains a series of $m$
lists, which contain the contact information of some nodes at a given
XOR-distance from them.
In particular, the $i$-th list of a given node contains
information regarding nodes at distance between $2^i$ and $2^{i+1}$ from 
it's ID.
The maximal capacity of these lists, $k$, is chosen to minimize the
probability that all the nodes in the lists fail at the same 
time and to minimize memory requirements.
This parameter is  known as \emph{system-wide replication parameter}.
Because of their maximal capacity the lists are denoted by the term
\emph{k-bucket}.
Each bucket is kept sorted: at the head we find the least-recently seen node
and at the tail the most recently one.
When a node receives a message from a sender, it uses
the Algorithm \autoref{alg:kademlia:update} to update the contact table.
One important feature of this Algorithm is that, when the node discover
a new node, the latter is added only if one of the already known at the same 
distance nodes are no more on-line. The rationale for this choice is due
to the observation that the more a node has been on-line, the more likely it is,
that it remains up another hour~\cite{bib:kademlia}.
% Description of the PROTOCOL's functions
The original Kademlia protocol is based on four RPC functions: \verb|PING|,
\verb|FIND_NODE|, \verb|STORE| and \verb|FIND_VALUE|, and their replies. In
Kademlia, \verb|STORE| and \verb|FIND_VALUE| are used, respectively, to save a
$\langle key, value\rangle$ pair in the DHT and later retrieve it.
Since these
features are not needed for a pure node discovery, they are not implemented in
the Ethereum variant. Indeed, there are only the \verb|PING| function, which is
used to check whether a node is still on-line or not, and the
\verb|FIND_NODE(ID)| call used to retrieve the $k$ neighbors closest to the
target \verb|ID|, known by the recipient of the message. In the RLPx
specification we can find also the \verb|PONG| and \verb|NEIGHBORS| instructions
that are the reply messages for \verb|PING| and \verb|FIND_NODE|, respectively.
Apart from the missing functions, RLPx has other important differences from
Kademlia: the IDs are 512 bit long, the XOR distance metric is done on the
sha3 (Keccak-256) of the IDs (a 256 bit long hash) and not directly on the
IDs, and finally the packets are signed with the public key corresponding to the
ID.

In order to join the network for the first time, a new node should generate a
new public-private key pair \footnote{The public key is the ID and the private
key is used to sign the packets.}, and know the address of at least one
participant. In Ethereum this task is accomplished by hard-coding the contact
information of some \textit{bootstrap nodes} in the client's code. The aim of
these nodes is to provide new nodes with contact information to other regular
nodes that are already participating in the network.

RLPx uses its own URL scheme, the \emph{enode}. In this scheme are specified the ID
of the node encoded in hexadecimal format, the IP-Address and the TCP-Port of
the node:
\begin{verbatim}
enode://<hexadecimal-node-id>@<IP>:<TCP-Port>[?discport:<UDP-PORT>]
\end{verbatim}
The \verb|discport| part is optional and is required only if the UDP port
(discovery port) does not correspond to the TCP one. The default discovery UDP
port is 30303.

