\subsection{Network layer}
\label{sec:network-layer}

The aim of this layer is to build the peer-to-peer network, a decentralized
architecture in which the nodes are logically equivalent and function as a
\emph{servent} (i.e. a node that acts as a client and a server at the same
time). In this type of architecture, the nodes are formed by processes and the
links represent the possible communication channels, that is, a
\textbf{structured overlay network} \cite{van2017distributed} in which the nodes
of the network can propagate the information efficiently. Essentially, this
layer is constituted by a slight modification of the Kademlia protocol
\cite{bib:kademlia}. In the Ethereum jargon, this protocol is known as
\textbf{RLPx Node Discovery Protocol}.

Before we continue describing in more details this protocol, we want to point
out that with (simply) RLPx, it is intended a protocol suite which has different
features. For the purpose of the this layer, it is able to form the underlying
network on which Ethereum works
\footnote{\url{https://github.com/ethereum/devp2p/blob/master/rlpx.md\#network-formation}}.

\paragraph{Kademlia protocol}
The Kademlia protocol is a distributed hash table (DHT) system based on the
XOR-metric for distance \cite{bib:kademlia}, that is the distance between two
keys $x$ and $y$ is given by $x \otimes y$. In Kademlia, each node has a unique
ID of 160-bit and maintains a series of lists (one for each $i$ in $0 \leq i <
160$) of $\langle \verb|IP Address|, \verb|UDP Port|, \verb|Node ID| \rangle$
triples. Each list contains contacts for nodes of distance between $2^i$ and
$2^{i+1}$ from the node's ID. Each list can contain at most $k$ elements and it
is therefore known as \textit{$k$-bucket}. Each bucket is sorted by the "last
seen" time: in the head we find the least-recently seen node and at the end the
most recently ones. When a node $R$ receives a message from a sender $S$, $R$
checks if the $k$-bucket corresponding to the sender's ID (SID) already contains
SID. If it is the case, SID is moved at the end of the list. Otherwise we should
distinguish two cases:
\begin{enumerate*}[label=(\arabic*)]
  \item if the $k$-bucket is full, then $R$ pings the head ($H$) of the
  $k$-bucket and, if this responds, $S$ is discarded and $H$ is put at the end
  of the list, otherwise $H$ is evicted and SID is inserted at the end of the
  list,
  \item otherwise (i.e. the is still space in the $k$-bucket), the SID is simply
  inserted at the end of the list
\end{enumerate*}.
The rationale to prefer already known contacts to the new ones discovered is due
to the observation that the more a node has been on-line, the more likely it is
to remain up another hour \cite{bib:kademlia}.

% Description of the PROTOCOL's functions
The original Kademlia protocol is based on four RPC functions: \verb|PING|,
\verb|FIND_NODE|, \verb|STORE| and \verb|FIND_VALUE|, and their replies. In
Kademlia, \verb|STORE| and \verb|FIND_VALUE| are used, respectively, to save a
$\langle key, value\rangle$ pair in the DHT and later retrieve it. Since these
features are not needed for a pure node discovery, they are not implemented in
the Ethereum variant. Indeed, there are only the \verb|PING| function, which is
used to check whether a node is still on-line or not, and the
\verb|FIND_NODE(ID)| call used to retrieve the $k$ neighbors closest to the
target \verb|ID|, known by the recipient of the message. In the RLPx
specification we can find also the \verb|PONG| and \verb|NEIGHBORS| instructions
that are the reply messages for \verb|PING| and \verb|FIND_NODE|, respectively.
Apart from the missing functions, RLPx has other important differences from
Kademlia: the IDs are 512 bit long, the XOR distance metric is done on the
sha3 (Keccak-256) of the IDs (a 256 bit long hash) and not directly on the
IDs, and finally the packets are signed with the public key corresponding to the
ID.

In order to join the network for the first time, a new node should generate a
new public-private key pair \footnote{The public key is the ID and the private
key is used to sign the packets.}, and know the address of at least one
participant. In Ethereum this task is accomplished by hard-coding the contact
information of some \textit{bootstrap nodes} in the client's code. The aim of
these nodes is to provide new nodes with contact information to other regular
nodes that are already participating in the network.

RLPx uses its own URL scheme, the \emph{enode}. In this scheme are specified the ID
of the node encoded in hexadecimal format, the IP-Address and the TCP-Port of
the node:
\begin{verbatim}
enode://<hexadecimal-node-id>@<IP>:<TCP-Port>[?discport:<UDP-PORT>]
\end{verbatim}
The \verb|discport| part is optional and is required only if the UDP port
(discovery port) does not correspond to the TCP one. The default discovery UDP
port is 30303.

