\subsection{Consensus Algorithm}
\label{sec:consensus}

Essentially, the aim of the blockchain technology
is to provide a \textbf{total order to transactions} in a distributed
ledger~\cite{bib:the-quest} without relying on a trusted third party. 
This permits to solve the double spending problem~\cite{bib:bitcoin}.
Moreover in Ethereum the order of transactions can also affect the execution
of smart contracts by altering the content of the storage.

Thus, finding an agreement on the order of transaction (i.e., the actual
blockchain) and the world status is crucial.
In general multiple consensus algorithms were proposed~\cite{}. 
Ethereum
follows an idea very close to the consensus algorithm of bitcoin, which
is also known in the literature as \textbf{Nakamoto consensus}~\cite{}.

The basic idea of this algorithm consists in: 
\begin{enumerate}
\item Accepting only valid blocks, and
\item Rely on a \textbf{selection rule} to choose between two different 
valid forks, depending on the amount of work performed in each fork. 
\end{enumerate}

The first point consists in checking that the blocks and transactions are
well-formed and in re-performing all the transactions, and in Ethereum
also re-execute \emph{all} the EVM computations to verify whether the
transaction receipts and the state root contained in the propagated block 
(\autoref{fig:world-state}) are valid.

The latter point is required to avoid the infamous double spending problem.
Indeed in Bitcoin (and also in Ethereum) the assumption is that the majority
of computing power belongs to players who will follow the rules\todo{add the
	exact proportion}. Therefore,
to prevent bad agents to rewrite the transaction history with a high 
probability~\cite{bib:bitcoin} the issuer of
new blocks should prove that they invested resources in its creation by
solving a computational heavy task.
This mechanism is known as \textbf{Proof-of-Work} (PoW).
In the case of bitcoin this task consists in finding a number (\emph{nonce})
such that the hash of the block along with the nonce itself begins with a
number of leading zeros. The difficulty of the task increase exponentially
with the number of leading zeros.
Since the output of the hash function is not predictable, the creator of 
a new block should try each possible nonce in a brute-force manner.
Once a valid nonce is found the block is spread and the receiver should
only perform a single hash to check that the result is valid.
In bitcoin the selection rule consists simply in accepting the longest
blockchain.