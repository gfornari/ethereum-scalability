\subsection{Overlay Network}
\label{sec:overlay-network}
The peer-to-peer network underlying Ethereum is maintained by means of an
overlay network known as devp2p. The devp2p network is based on the
RLPx node discovery protocol and the devp2p-Wire protocols.
The former is used to keep up-to-date contacts about
the nodes of the network and at the same time to guarantee logarithmic time
spread of the blockchain information,
while the latter makes it possible to participate to the
blockchain's consensus.

\subsubsection{RLPx}

The RLPx protocol suite's objectives are manifold.
On the one hand it allows the maintenance of the peer to peer network
and a routing table for each peer through an UDP\footnote{All communications
except those for the node discovery use TCP messages.} node discovery
protocol.
On the other hand it provides a transport layer for the devp2p wire protocols
(Section \ref{sec:devp2p-wire-protocol}) to send their messages.
For security reasons these messages between the peers should be
authenticated and encrypted. Therefore RLPx provides a first handshake,
in which the peers exchange a cryptographic
secret, i.e. a set of tokens used to encrypt the messages
between them\footnote{It is beyond the scope of this report to
	describe the exact procedure. For further details we refer to the official
	documentation~\cite{} and to the go ethereum implementation~\path{}.}.
This secret is valid until no subsequent connection between them fails.
The RLPx protocol suite takes its name by the union of \textbf{RLP} and
\textbf{extended}. The Recursive Length
Protocol~\cite{wood2018ethereum,bib:ethereumrlpspec} is
the serialization algorithm used in Ethereum to both marshal the content of
the RLPx messages to send over the wire and to store information locally.
Details about how does it work are reported in appendix~\ref{sec:appendix:RLP}. 





\paragraph{Node discovery}
The RLPx node discovery is derived from the Kademlia protocol,
a distributed hash table (DHT) system~\cite{bib:kademlia}
based on the XOR-metric for
distance, i.e. the distance between two keys $x$ and $y$ is given
by $x \otimes y$.
In Kademlia each node has a (unique) ID of 160-bit and maintains a
series of lists (one for each $i$ in $0 \leq i < 160$) of
$\langle \verb|IP-Address|, \verb|UDP-Port|, \verb|Node ID| \rangle$ triples.
Each list contains contacts for nodes of distance between $2^i$ and $2^{i+1}$
from the node's ID.
Each list can contain at most $k$ elements and is therefore known as
\textit{$k$-bucket}.
Each bucket is sorted by the time last
seen: in the head we find the least-recently seen node and at the end the most
recently ones.
When a node $R$ receives a message from a sender $S$, $R$ checks if the
$k$-bucket corresponding to the sender's ID (SID) already contains SID.
If it is the case SID is moved at the end of the list. Otherwise we should
distinguish two cases depending on whether the k-bucket is full or not.
In the former case $R$ pings the head ($H$) of the $k$-bucket and if
this responds, $S$ is discarded and $H$ is put at the end of the list,
otherwise $H$ is evicted and SID is inserted at the end of the list.
In the latter case the SID is simply inserted at the end of the list.
The rationale to prefer already known contacts to the new ones discovered
is due to the observation that the more a node has been on-line the more
likely it is to remain up another hour~\cite{bib:kademlia}.

% Description of the PROTOCOL's functions
The original Kademlia protocol is based on the four RPC functions
\verb|PING|, \verb|FIND_NODE|,
\verb|STORE| and \verb|FIND_VALUE| and their replies.
In Kademlia \verb|STORE| and \verb|FIND_VALUE| are used to save a
$\langle key, value\rangle$ pair in the DHT and later retrieve it, respectively.
Since these features are not needed for a pure node discovery, they
are not implemented in RLPx.
In RLPx there are only the \verb|PING| RPC, which is used to check whether a
node is still on-line or not and the \verb|FIND_NODE(ID)| call that is used to
retrieve the $k$ neighbors closest to the target \verb|ID|, known by the
recipient of the message. In the RLPx specification we can find also
the \verb|PONG| and \verb|NEIGHBORS| instructions that are the reply messages
for \verb|PING| and \verb|FIND_NODE|, respectively.
Apart from the missing functions RLPx has other important differences
from Kademlia:
the IDs are $512$ bit long, the XOR distance metric is done on the sha3
(Keccak-256) of the IDs (that is $256$ bit long) and not on the IDs and
finally the packets are signed and the public key corresponds to the ID.

In order to join the network for the first time a new node should
generate a new key pair
\footnote{The public key is the ID and the private key is used to sign the packets}, and
know the address of at least one participant.
In Ethereum this task is resolved by hard-coding the contact information
of some \textit{bootstrap nodes} in the client's code.
The aim of these nodes is to provide to new nodes, contact information to
other regular nodes that are already participating in the network.

RLPx uses its own URL scheme, \emph{enode}.
In this scheme are specified the ID of the node encoded in hexadecimal format,
the IP-Address and the TCP-Port of the node:
\begin{verbatim}
enode://<hexadecimal-node-id>@<IP>:<TCP-Port>[?discport:<UDP-PORT>]
\end{verbatim}
The \verb|discport| part is optional and is required only if the
UDP port (discovery port) does not correspond to the TCP one.
The default discovery UDP port is 30303.



\subsubsection{Devp2p-Wire Protocol}
\label{sec:devp2p-wire-protocol}
This protocol exploits RLPx and have the four message types
\textbf{Hello}, \textbf{Disconnect}, \textbf{Ping} and \textbf{Pong}.
The Hello (Handshake)message is used upon connection and upon receiving a
Hello message.
The Hello message specifies the protocol version, the client's id,
a string that uniquely identifies a client program, the capabilities and their
version, the port on which the client listen and finally the ID of the node.
The capabilities are the application level protocols supported by the sender
of the Hello Message. At the moment of writing this essay only the protocols
eth (Ethereum), les (light Ethereum Subprotocol), bzz (Swarm) and
shh (whisper) are used. In the following
Section we will describe the Ethereum Wire Protocol, i.e. the application
level protocol of Ethereum.
The disconnect message notifies the receiver that the sender is going to
disconnect itself. The disconnect message can specify optionally an
integer that encodes a reason.
For the complete reason codes we refer to the devp2p specification~\cite{}.
The Ping and Pong message are used to check whether the counterpart is still
on-line or not.

\paragraph{Ethereum Wire Protocol}
The Ethereum wire protocol
(\textit{eth})~\cite{bib:ethereumwireprotocol} is used to spread the information
about the blockchain and for the synchronization. There are several versions
of this protocol. Throughout this section we will consider only the versions
$62$ and $63$ (which are compatible) that are currently supported by the go
Ethereum client (v. 1.8.3).

The first message that must be exchanged between two peers
is the \textbf{Status} message. This kind of message is used to exchange
the: protocol version, the network IDs, the total difficulty of the
heaviest chain known, the best hash, the hash of the best known block and
finally the genesis block's hash. This message should be sent only during
the handshake phase.
If the network id, the genesis id are different or the supported
\textit{eth} protocol version are not compatible the peers should
drop the connection, since they are either on different chain or cannot
communicate with each other.

\subparagraph{Protocol Version 62 - Model Syncing}
To spread the presence of one or more blocks to peers that are not aware
of them the \textbf{NewBlockHashes} message type is used.
Moreover the \textbf{Transactions} message type spreads transactions to
peers who are not aware of them. It is specified that
in the same session a peer should not send twice the same
transaction to a
recipient\footnote{To this extent the
geth implementation (in the file \path{eth/peer.go}) keeps track for each
peer of the set of transactions hash (\texttt{knowTxs}) and the set of
block hash (\texttt{knownBlocks}) known to be known by it.}.
The \textbf{GetBlockHeaders} message type requests to the recipient at most
\texttt{maxHeaders} block headers descendant from the block with a given
number or a given hash.
The recipient of the message should respond with a \textbf{BlockHeaders}
message, in which it has the faculty to send a reply with less than
\texttt{maxHeaders} headers. Clearly, if the recipient of a message
is not aware of any descendant of the given block, it sends a valid empty
reply. Furthermore to request and to receive the real content of the blocks the
peers have the \textbf{GetBlockBodies} and \textbf{Blockbodies} messages.
The requester specifies the hashes of the blocks it wants and the recipient
replies with the bodies (i.e. the transactions and the uncles) of
the required block(s).
Finally the \textbf{NewBlock} spreads a single new block.

\subparagraph{Version 63 - Fast synchronization}
From version v. x of geth it is possible to perform a fast synchronization.
This synchronization type does not require that a node performs \emph{all} the
computations happened during the history (i.e. the whole EVM instructions).
Indeed the synchronizer downloads along the blockchain the transaction receipts,
i.e. useful information about the execution of the transaction.
This allows the synchronizer to deal only with the verification of the
proof-of-work. At least in geth this synchronization is possible only by the
first synchronization for security
reasons~\footnote{\url{https://github.com/ethereum/go-ethereum/pull/1889}}.
After the synchronizer reaches a \textit{pivot point} ($head - 1024$) it
retrieves the whole current state and afterwards processes the blockchain
normally.
To perform this synchronization the clients dispose have available
the \textbf{GetReceipts} and \textbf{Receipts} messages, which are the
request for the receipts given the hash and the replies, respectively.
Besides these there are also the \textbf{GetNodeData} and
\textbf{NodeData} message types which provides the mean to exchange
\todo{Add what is a node data. It is not clear in the specification}.




